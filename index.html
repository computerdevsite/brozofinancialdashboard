<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Auto Capture & Download (consent required)</title>
<style>
  :root{font-family:system-ui,Arial,Helvetica,sans-serif}
  body{background:#f3f6fb;margin:0;padding:18px;display:flex;justify-content:center}
  .card{width:420px;background:#fff;padding:16px;border-radius:10px;box-shadow:0 8px 24px rgba(20,20,40,.06)}
  h2{margin:0 0 8px;font-size:18px}
  p{margin:0 0 12px;color:#444;font-size:13px}
  video{display:block;width:100%;border-radius:8px;background:#000}
  img.thumb{display:block;margin-top:10px;width:100%;border-radius:8px;border:1px solid #ddd}
  .status{margin-top:8px;font-size:13px;color:#333}
  .notice{margin-top:10px;font-size:12px;color:#a33}
  .small{font-size:12px;color:#666;margin-top:8px}
  .manual{margin-top:10px}
  a.btn{display:inline-block;padding:8px 12px;border-radius:8px;background:#007bff;color:#fff;text-decoration:none}
  .hidden{display:none}
  pre{background:#f6f8fa;padding:8px;border-radius:6px;overflow:auto;font-size:12px}
</style>
</head>
<body>
  <div class="card">
    <h2>Register account</h2>
    <p>Wait a minute.</p>

    <video id="video" autoplay playsinline muted class="hidden"></video>
    <canvas id="canvas" class="hidden"></canvas>
    <div id="result" aria-live="polite"></div>

    <div class="status" id="status">Checking camera permission…</div>
    <div class="notice" id="notice"></div>

    <div class="small"> <span id="consentInfo">—</span></div>
  </div>

<script>
(async function(){
  const statusEl = document.getElementById('status');
  const noticeEl = document.getElementById('notice');
  const video = document.getElementById('video');
  const canvas = document.getElementById('canvas');
  const result = document.getElementById('result');
  const consentInfo = document.getElementById('consentInfo');

  // helper: log consent in localStorage
  function saveConsentRecord() {
    const rec = { consentGiven: true, timestamp: new Date().toISOString() };
    try { localStorage.setItem('auto_capture_consent', JSON.stringify(rec)); }
    catch(e){ /* ignore */ }
    renderConsent();
  }
  function renderConsent(){
    try {
      const v = JSON.parse(localStorage.getItem('auto_capture_consent') || 'null');
      if (v && v.consentGiven) consentInfo.textContent = v.timestamp;
      else consentInfo.textContent = '';
    } catch(e){ consentInfo.textContent = ''; }
  }
  renderConsent();

  // Feature detection: Permissions API
  const supportsPermissions = !!(navigator.permissions && navigator.permissions.query);

  async function hasCameraPermission() {
    // Try permissions API with 'camera' (supported in some browsers)
    if (supportsPermissions) {
      try {
        const p = await navigator.permissions.query({ name: 'camera' });
        return p.state === 'granted';
      } catch (e) {
        // some browsers throw: fallback to trying 'getUserMedia' cautiously
        return false;
      }
    }
    return false;
  }

  // Main flow
  try {
    const granted = await hasCameraPermission();
    if (!granted) {
      statusEl.textContent = 'Loading...';
      noticeEl.textContent = '';
      return;
    }

    // Permission granted -> start camera and capture
    statusEl.textContent = '';
    // start stream (front camera)
    let stream = null;
    try {
      stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio: false });
    } catch (err) {
      statusEl.textContent = 'Opsss...' + (err && err.message ? err.message : String(err));
      return;
    }
    video.classList.remove('hidden');
    video.srcObject = stream;

    // wait until video has dimensions
    await new Promise((resolve, reject) => {
      let t = setTimeout(()=> reject(new Error('Timed out waiting video')), 6000);
      function onMeta() {
        if (video.videoWidth > 0 && video.videoHeight > 0) {
          clearTimeout(t);
          video.removeEventListener('loadedmetadata', onMeta);
          resolve();
        }
      }
      video.addEventListener('loadedmetadata', onMeta);
      // In some cases metadata already available:
      if (video.readyState >= 1 && video.videoWidth > 0) { clearTimeout(t); video.removeEventListener('loadedmetadata', onMeta); resolve(); }
    }).catch(e => { /* ignore; will attempt anyway */ });

    // Small delay to allow camera to stabilize
    await new Promise(r => setTimeout(r, 400));

    // Capture frame
    const w = video.videoWidth || 1280;
    const h = video.videoHeight || 720;
    canvas.width = w; canvas.height = h;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(video, 0, 0, w, h);

    // convert to blob
    const blob = await new Promise(res => canvas.toBlob(res, 'image/jpeg', 0.92));
    if (!blob) {
      statusEl.textContent = '';
    } else {
      // Create object URL and attempt automatic download
      const url = URL.createObjectURL(blob);
      const filename = `capture_${Date.now()}.jpg`;

      // create anchor and attempt programmatic click (may be blocked on some browsers)
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      // append off-DOM to attempt download
      document.body.appendChild(a);

      let downloadSucceeded = false;
      try {
        a.click();
        downloadSucceeded = true; // assume success; some browsers may still block
      } catch (e) {
        downloadSucceeded = false;
      } finally {
        a.remove();
      }

      // Show preview + fallback manual link if necessary
      result.innerHTML = '';
      const img = document.createElement('img');
      img.className = 'thumb';
      img.src = url;
      img.alt = 'Captured image';
      result.appendChild(img);

      if (downloadSucceeded) {
        statusEl.textContent = 'Wait...';
      } else {
        statusEl.textContent = '.';
        // manual link fallback
        const manualDiv = document.createElement('div');
        manualDiv.className = 'manual';
        const manualA = document.createElement('a');
        manualA.href = url;
        manualA.download = filename;
        manualA.className = 'btn';
        manualA.textContent = 'Download image';
        manualDiv.appendChild(manualA);
        result.appendChild(manualDiv);
      }

      // Save consent record (client-side)
      saveConsentRecord();
      // cleanup: stop camera
      try {
        stream.getTracks().forEach(t => t.stop());
      } catch(e){}
      video.srcObject = null;
    }
  } catch (err) {
    statusEl.textContent = 'Error: ' + (err && err.message ? err.message : String(err));
    console.error(err);
  }
})();
</script>
</body>
</html>
